/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.twiceagain.selescript;

import com.twiceagain.selescript.exceptions.SSException;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Scanner;
import java.util.SortedSet;
import java.util.TreeSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Configuration information and various tools.
 *
 * @author xavier
 */
public class Config {

    /**
     * Target directory where the generated scrapper project will be put
     */
    protected static File TARGETDIR = new File("./target/scrapper-dist/");
    /**
     * Package for target generated scrapper.
     */
    protected List<String> TargetPackage = Arrays.asList("com", "twiceagain", "scrapper");
    /**
     * The name of the generated java class.
     */
    protected String JavaClassName = "AutoScrapper";
    /**
     * List of required imports.
     */
    protected static final List<String> TARGETIMPORTS = Arrays.asList(
            "java.util.*",
            "org.openqa.selenium.*",
            "org.openqa.selenium.remote.*",
            "org.slf4j.*"
    );
    /**
     * File systems separator used.
     */
    public static final String FILESEPARATOR = FileSystems.getDefault().getSeparator();
    /**
     * New line separator used
     */
    public static final String NL = System.lineSeparator();
    public static final String AP = "\"";

    /**
     * Unique ID generation.
     */
    private transient static long UID = 0L;

    private static final Logger LOG = LoggerFactory.getLogger(Config.class);

    private static final String SELESCRIPTVERSION = "1.2";

    static {
        LOG.info("Selescript compiler");
        LOG.info("Version " + SELESCRIPTVERSION);
        LOG.info("(c) 2018 - Xavier Gandillot");
        LOG.info("See details on https://github.com/xavier268/selescript");
    }

    public Config() {

    }

    public Config(String className) {
        this.JavaClassName = className;
    }

    public Config setTargetPackage(String... args) {
        TargetPackage = Arrays.asList(args);
        return this;
    }

    public String getVersion() {
        return SELESCRIPTVERSION;
    }

    public String getSeleniumVersion() {
        return "3.14.0";
    }

    /**
     * Get the comment / licence bloc from the file header.
     *
     * @return
     */
    public String getFileHeader() {
        List<String> content = Arrays.asList(
                "===================================================",
                "Autogenerated file - DO NOT EDIT DIRECTLY",
                " (c) 2018 - Xavier Gandillot",
                " Generated on " + new Date().toString(),
                " by selescript version : " + getVersion(),
                " target selenium version : " + getSeleniumVersion(),
                "",
                " See https://github.com/xavier268/selescript for details",
                "===================================================="
        );
        return "/*" + String.join(NL + "* ", content) + NL + "*/" + NL;

    }

    public String getPackageDeclaration() {
        return "package " + String.join(".", TargetPackage) + ";" + NL;
    }

    public String getImportsDeclarations() {
        StringBuilder sb = new StringBuilder();
        TARGETIMPORTS.forEach((s) -> {
            sb.append("import ")
                    .append(s)
                    .append(" ;")
                    .append(NL);
        });
        return sb.toString();
    }

    /**
     * Reads a UTF-8 text resource file into memory as a String.
     *
     * @param sourceName : relative to the ressource directory.
     * @return
     */
    public String getResourceAsString(String sourceName) {
        return new Scanner(Config.class.getClassLoader().getResourceAsStream(sourceName), "UTF-8")
                .useDelimiter("\\A")
                .next();
    }

    public String getBuiltinsMethods() {
        return getResourceAsString("rt/builtins.methods");
    }

    /**
     * Reads a whitespace or nl separated list of tokens, keeping only those
     * prefixed with $.
     *
     * @return
     */
    public Collection<String> getBuiltinsList() {
        SortedSet<String> rr = new TreeSet<>();
        new Scanner(Config.class.getClassLoader().getResourceAsStream("rt/builtins.list"), "UTF-8")
                .tokens()
                .filter((String x) -> {
                    return x.startsWith("$");
                })
                .forEach(rr::add);
        return rr;

    }

    /**
     * Retrieve the target directory.
     *
     * @return
     */
    public String getTargetDir() {
        try {
            return TARGETDIR.getCanonicalPath();
        } catch (IOException ex) {
            throw new SSException("Invalid default path : " + TARGETDIR.toString());
        }
    }

    public final String getTargetJavaClassName() {
        return JavaClassName;
    }

    /**
     * The path to the directory where the generated java class will be.
     *
     * @return
     */
    public Path getTargetJavaClassDirectory() {
        return Paths.get(getTargetDir(), "src", "main", "java", String.join(FILESEPARATOR, TargetPackage));
    }

    /**
     * The path to the default generated java class file.
     *
     * @return
     */
    public Path getTargetJavaClassPath() {
        return getTargetJavaClassPath(getTargetJavaClassName());
    }

    /**
     * The path to any class name of the default package.
     *
     * @param className
     * @return
     */
    public Path getTargetJavaClassPath(String className) {
        return Paths.get(getTargetJavaClassDirectory().toString(), className + ".java");

    }

    /**
     * Copy the file from the ressources to the target directory.
     *
     * @param source - relative to the root of the resources directory.
     * @param target - relative to the TARGETDIRECTORY
     */
    protected void copyFromResource(String source, String target) {

        new File(getTargetDir()).mkdirs();

        BufferedInputStream is = null;
        BufferedOutputStream os = null;

        try {
            is = new BufferedInputStream(Config.class
                    .getClassLoader()
                    .getResourceAsStream(source));

            if (is == null) {
                throw new SSException("Could not open requestde resources : " + source);
            }
            os = new BufferedOutputStream(
                    new FileOutputStream(
                            getTargetDir()
                            + "/" + target));

            byte[] readBytes = new byte[1024 * 8];
            int read;

            while ((read = is.read(readBytes)) != -1) {
                os.write(readBytes, 0, read);

            }

        } catch (IOException ex) {
            throw new SSException("IOException copying from  " + source + " to " + target, ex);
        } finally {
            try {
                if (is != null) {
                    is.close();
                }
                if (os != null) {
                    os.close();
                }
            } catch (IOException ex) {
                throw new SSException(ex);
            }
        }

    }

    public void copyAllRuntimeFiles() {

        copyFromResource("rt/pom", "pom.xml");
        copyFromResource("rt/run.sh", "run.sh");
        
        // Docker/swarm environment
        copyFromResource("rt/selgrid.yaml", "selgrid.yaml");
        copyFromResource("rt/selgrid.start.sh", "selgrid.start.sh");
        copyFromResource("rt/selgrid.stop.sh", "selgrid.stop.sh");
        
        // Readme
        copyFromResource("rt/README.txt", "README.txt");

    }

    /**
     * Save code to a java class in the default package location.
     *
     * @param code - the String reprensenting the entire code to be saved.
     * @param className - the className
     */
    public void saveCode(String code, String className) {

        getTargetJavaClassDirectory().toFile().mkdirs();

        copyAllRuntimeFiles();

        Path p = getTargetJavaClassPath(className);
        try {
            Files.write(p, code.getBytes("UTF-8"));
        } catch (IOException ex) {
            throw new SSException(ex);
        }

    }

    public void saveCode(String code) {
        saveCode(code, getTargetJavaClassName());
    }

    public void saveCode(StringBuilder code) {
        saveCode(code.toString());
    }

    /**
     * Generates a unique, valid java identifier.
     *
     * @return
     */
    public String getUniqueId() {
        UID++;
        return String.format("uid_%d", UID);
    }

}
