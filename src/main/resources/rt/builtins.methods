
    /*=============================================
     ***** start of file : builtin.methods ********    
     ==============================================*/
    
    /**
     * Log resource.
     */
    private final static Logger LOG = LoggerFactory.getLogger(CLASS);
    /**
     * Symbol table.
     */
    protected Map<String, String> symtab = new HashMap<>();

    /**
     * Stack(deque) holding current search context at the top, and wd at the
     * bottom.
     */
    protected Deque<SearchContext> wes = new ArrayDeque<>();

    

    /*------------------------------------------------------------
    * A dedicated concatenation that behaves well with null values.
    * null + null = null
    * null + a = a
    * a + null = a
    * a + b = ab
    **/
    protected String plus(String s1, String s2) {
        if (s1 == null) {
            return s2;
        }
        if (s2 == null) {
            return s1;
        }
        return s1 + s2;
    }

    /*--------------------------------------------------
    * A dedicated equal that behave well with null values.
    * null eq null = ""
    * null eq a = null
    * a eq null = null
    * a eq b = a.equals(b)
    **/
    protected String aq(String s1, String s2) {
        if (s1 == null && s2 == null) {
            return "";    // true   
        }
        if (s1 == null || s2 == null) {
            return null; // false
        }
        if (s1.equals(s2)) {
            return "";            // true
        }
        return null;                             // false
    }

    /*---------------------------------------------------
    * A dedicated not that behaves well will null values
    * ! null = ""
    * ! a = null
    **/
    protected String not(String s) {
        return (s == null) ? "" : null;
    }


    /**---------------------------------------------------------------------
     * Implements the dereferencing operator. Return null if not valid. Once
     * derefererenced, if attribute is specified, return the string value of
     * that attribute. If no attribute is specified, apply getText() to the
     * first WebElement found.
     *
     * @param attr
     * @param s
     * @return
     *
     */
    protected String at(String attr, String s) {
        try {
            if (s == null || s.isEmpty()) {
                return null;
            }
            List<WebElement> lwe = wes.getLast().findElements(By.xpath(s));
            if (lwe.isEmpty()) {
                return null;
            }
            if (attr == null) {
                return lwe.get(0).getText();
            } else {
                return lwe.get(0).getAttribute(attr);
            }
        } catch (Exception ex) {
            LOG.info("Error while dereferencing xpath : " + attr + ":" + s , ex);
            return null;
        }

    }


    /*----------------------------------------------------
    * Emits the provided fields to stout.
    **/
    public void emit(String ... par) {
        Integer count = 0;      
        List<String> ls = new ArrayList<>();
        
        for(int i=0;  i<par.length;i+=2) {
            count ++;
            StringBuilder sb = new StringBuilder();
             if(par[i] == null) {
                sb.append("\"F_").append(count).append("\":");
                } else {
                sb.append("\"").append(par[i]).append("\":");
                }
             
            sb.append("\"").append(par[i+1]).append("\"");
                
            ls.add(sb.toString());
            }
         System.out.printf("%n{%s}%n", String.join(",",ls)); 
         }



    /**
     * ---------------------------------------------------------------
     *
     * Click on the first WebElement that matches the provided xpath.
     *
     * @param wd
     * @param xpath
     */
    protected void click(WebDriver wd, String xpath) {
        click(wd, xpath, false);
    }
    protected void clickw(WebDriver wd, String xpath) {
        click(wd, xpath, true);
    }

    /**
     * --------------------------------------------------------------
     *
     * Click on the first WebElement that matches the provided xpath.
     *
     * @param wd
     * @param xpath
     * @param linkShouldGo - Set to true if the link we click is expected to
     * trigger a page reload.
     *
     */
    protected void click(WebDriver wd, String xpath, boolean linkShouldGo) {
        if (xpath == null) {
            return;
        }
        List<WebElement> lwe = wes.getLast().findElements(By.xpath(xpath));
        if (lwe.isEmpty()) {
            return;
        }
        lwe.get(0).click();

        if (linkShouldGo) {
            // Wait up to 5 seconds for the page to disappear.
            (new WebDriverWait (wd, 5)).until(ExpectedConditions.stalenessOf(lwe.get(0)));
        }

    }



    /**
     * Static method just delegates to the non-static main() method.
     *
     * @param args
     */
    public static void main(String[] args) {
        // Just create the object and lunch init.
        newInstance().main();
    }

    /**
     * The non-static equivalent of main. Opens a single window, and launches
     * the scrapping. Closes everything at the end.
     */
    public void main() {
        final WebDriver wd = new RemoteWebDriver(DesiredCapabilities.firefox());
        
        try {
            wes.clear();
            wes.add(wd);
            scrap(wd);
        } catch (Exception ex) {
            LOG.info(ex.getMessage());
        } finally {
            wes.clear();
            wd.quit();
        }
    }


    /**
     * Iterates over the webelements obtained applying xpath to the provided
     * search context. Since some webelemnts can appear later, it refreshs
     * regularly while iterating.
     */
    public static class WebElementIterator implements Iterable<WebElement>, Iterator<WebElement> {

        private final String xpath;
        private final SearchContext sc;
        private final Deque<WebElement> tovisit = new ArrayDeque<>();
        private final Set<WebElement> visited = new HashSet<>();


        /**
         * Will iterate over all the WebElements found by applying the provided
         * xpath of the provided search context.
         *
         * @param sc
         * @param xpath
         */
        public WebElementIterator(SearchContext sc, String xpath) {            
            this.sc = sc;
            this.xpath = xpath;
        }

        /**
         * Updates the list of WebElements to visit, excluding the ones we
         * already got. It also puts the current search context at the end of
         * the queue.
         */
        protected void refresh() {
            sc.findElements(By.xpath(xpath)).forEach(
                    (WebElement w) -> {
                        if (!visited.contains(w)) {
                            tovisit.add(w);
                        }
                    });
        }

        @Override
        public boolean hasNext() {
            if (tovisit.isEmpty()) {
                refresh();
            }
            return !tovisit.isEmpty();
        }

        /**
         * Warning : calling next() will put the provided WebElement on top of
         * the stack. It is up to the program to remove it with removeLast();
         *
         * @return
         */
        @Override
        public WebElement next() {

            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            WebElement w = tovisit.pop();
            visited.add(w);
            return w;
        }

        @Override
        public Iterator<WebElement> iterator() {
            return this;
        }

    }

    /*=============================================
     **** end of file : builtins.methods **********
    ==============================================*/
    
    
